{
    "id": "wild-animals-len",
    "name": "Wild Animals Len",
    "description": "Abstract argumentation framework using Clingo to compute argument status (accepted/defeated/drawn) based on attack relationships between wild animals.",
    "domainLanguageLines": [
        "@Engine(\"duckdb\", clingo: {time_limit: ∞, models_limit: ∞});",
        "",
        "ClingoModels() = RunClingo(",
        "\"\"\"",
        "% wild animals example",
        "",
        "attacks(\"B\",\"A\").",
        "attacks(\"B\",\"T\").",
        "attacks(\"C\",\"B\").",
        "attacks(\"D\",\"C\").",
        "attacks(\"E\",\"B\").",
        "attacks(\"E\",\"D\").",
        "attacks(\"F\",\"B\").",
        "attacks(\"G\",\"S\").",
        "attacks(\"H\",\"F\").",
        "attacks(\"I\",\"E\").",
        "attacks(\"J\",\"I\").",
        "attacks(\"K\",\"I\").",
        "attacks(\"L\",\"I\").",
        "attacks(\"M\",\"E\").",
        "attacks(\"M\",\"O\").",
        "attacks(\"M\",\"N\").",
        "attacks(\"N\",\"J\").",
        "attacks(\"O\",\"I\").",
        "attacks(\"O\",\"M\").",
        "attacks(\"Q\",\"G\").",
        "attacks(\"Q\",\"H\").",
        "attacks(\"Q\",\"C\").",
        "attacks(\"S\",\"E\").",
        "attacks(\"S\",\"F\").",
        "attacks(\"T\",\"S\").",
        "attacks(\"U\",\"T\").",
        "attacks(\"V\",\"B\").",
        "attacks(\"V\",\"U\").",
        "attacks(\"W\",\"B\").",
        "attacks(\"X\",\"D\").",
        "attacks(\"Y\",\"B\").",
        "attacks(\"Z\",\"C\").",
        "",
        "",
        "#const state_max = 100.",
        "",
        "pos(X) :- attacks(X,_).",
        "pos(X) :- attacks(_,X).",
        "",
        "% win-e rule in \"doubled form\" (2 rounds for 1, simplifying queries & termination)",
        "win_o(S, X) :- attacks(Y,X), not win_u(S,Y), next(S,_).  % (1)",
        "win_u(S1,X) :- attacks(Y,X), not win_o(S,Y), next(S,S1). % (2)",
        "",
        "% First-Green: when was a win_u first derived?",
        "fg(S1,X) :- next(S,S1), not win_u(S,X), win_u(S1,X).  % (3)",
        "",
        "% First-Red: when did a loss first drop from win_o?",
        "fr(0,X)  :- pos(X), not win_o(0,X).",
        "fr(S1,X) :- next(S,S1), not final(S), win_o(S,X), not win_o(S1,X). % (4)",
        "",
        "% (5) Generating new states, as long as necessary",
        "next(0,1).",
        "next(S,S1) :- fg(S,X), S1 = S+1, S < state_max.                       % (5)",
        "",
        "% Using clingo's \"_\" semantics to obtain final state (second last)",
        "final(S) :- next(S,S1), not next(S1,_). % not \\exists _ .. % (6)",
        "",
        "% (7,8,9) Solutions (position values) calculation with length",
        "len(accepted,X,L) :- fr(S,X), L = 2*S.   % Two plies = one e:  len = 0,2,4, ..",
        "len(defeated,X,L) :- fg(S,X), L = 2*S-1. % Green is 1 ply behind: len = 1,3,5, ..",
        "len(undefined,X,\"∞\") :- pos(X), not len(accepted,X,_), not len(defeated,X,_). % Gap = draws",
        "",
        "",
        "#show attacks/2.",
        "#show len/3.",
        "\"\"\");",
        "",
        "OneModel(model) :-",
        "  models = ClingoModels(),",
        "  model = models[0];",
        "",
        "Attacks(a1, a2) :-",
        "  OneModel(model),",
        "  att in model.model,",
        "  att.predicate == \"attacks\",",
        "  args = att.args,",
        "  a1 = args[0],",
        "  a2 = args[1];",
        "",
        "RawLen(status:a1, argu:a2, len:a3):-",
        "  OneModel(model),",
        "  length in model.model,",
        "  length.predicate == \"len\",",
        "  args = length.args,",
        "  a1 = args[0],",
        "  a2 = args[1],",
        "  a3 = args[2];",
        "",
        "# Remove quote for the infinite",
        "Len(status:, argu:, len: Element(test, 1)) :- RawLen(status:, argu: , len:l1), test = Split(l1, \"\"), Length(l1)>2;",
        "Len(status:, argu:, len: ) :- RawLen(status:, argu: , len:), Length(len)<2;"
    ],
    "visualLanguageLines": [
        "# Graph properties",
        "Graph( id: \"af\", rankdir: \"BT\", engine: \"dot\");",
        "",
        "# Node definitions - map domain arguments to visual nodes",
        "Node( node_id: x, label: la, shape: \"circle\", style: \"filled\", color:\"#40cfff\", fontsize: \"14\") :- Len(status:\"accepted\", argu: x, len: l), la = Join([x,l],\".\");",
        "",
        "Node( node_id: x, label: la, shape: \"circle\", style: \"filled\", color:\"#ffb763\", fontsize: \"14\") :- Len(status:\"defeated\", argu: x, len: l),la = Join([x,l],\".\");",
        "",
        "Node( node_id: x, label: la, shape: \"circle\", style: \"filled\", color:\"#FEFE62\", fontsize: \"14\") :- Len(status:\"undefined\", argu:x, len:l),la = Join([x,l],\".\");",
        "",
        "# from small number to large number",
        "Edge(source_id: source, target_id: target, color: \"black\", style: \"solid\", arrowhead: \"normal\", arrowtail: \"\", dir: \"forward\") distinct :-  Attacks(source, target), Len(argu:source, len:l1), Len(argu:target, len:l2), l1 < l2, l1!=\"∞\", l2!=\"∞\";",
        "",
        "# against the wind",
        "Edge(source_id: target, target_id: source, color: \"black\", style: \"solid\", arrowhead: \"normal\", arrowtail: \"\", dir: \"back\") distinct :-  Attacks(source, target), Len(argu: source, len:l1), Len(argu: target, len: l2), l1>l2;",
        "",
        "Edge(source_id: source, target_id: target, color: \"black\", style: \"solid\", arrowhead: \"normal\", arrowtail: \"\", dir: \"forward\") distinct :- Attacks(source, target), Len(argu: source, len: \"∞\"), Len(argu: target, len: \"∞\");",
        "",
        "# Ranking predicate for explicit rank constraints",
        "Ranking(len: l, samerank?List=x) distinct :- Len(argu: x, len: l), l in [\"0\",\"1\",\"2\"];"
    ]
}